<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Trox ‚Äî ÿßŸÑŸÅÿ∂ÿßÿ°</title>
<meta name="description" content="ŸÅÿ∂ÿßÿ° ÿßŸÑŸÉÿ®ÿ≥ŸàŸÑÿßÿ™ ‚Äî ÿ™ÿ¨ÿ±ÿ®ÿ© ŸÖŸàÿ®ÿßŸäŸÑ ÿ£ŸàŸÑŸãÿß">
<style>
  html,body{height:100%;margin:0;background:#000;font-family:"Cairo",system-ui;color:#eaffff;overflow:hidden}
  #wrap{position:fixed;inset:0;z-index:0}
  /* UI */
  #ui-top{position:fixed;left:12px;right:12px;top:12px;z-index:60;display:flex;justify-content:space-between;align-items:center;pointer-events:none}
  .brand{pointer-events:auto;display:flex;gap:10px;align-items:center;background:rgba(255,255,255,0.02);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .mark{width:40px;height:40px;border-radius:8px;background:linear-gradient(90deg,#00d4ff,#9b6aff);display:flex;align-items:center;justify-content:center;font-weight:800;color:#001}
  .actions{pointer-events:auto;display:flex;gap:8px}
  .btn{padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);color:#00d4ff;font-weight:700;cursor:pointer}
  .btn.primary{background:linear-gradient(90deg,#00d4ff,#9b6aff);color:#001}
  #hint{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);z-index:60;background:rgba(0,0,0,0.45);padding:8px 12px;border-radius:999px;color:#9fb0c7;pointer-events:auto;font-weight:700}
  /* overlay */
  #overlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:80;min-width:280px;max-width:90vw;background:linear-gradient(180deg,rgba(6,10,16,0.98),rgba(2,4,8,0.98));border-radius:12px;padding:14px;border:1px solid rgba(0,212,255,0.08);display:none}
  #overlay h3{margin:0;color:#00d4ff}
  #overlay p{white-space:pre-wrap;margin-top:8px;color:#dbefff}
  #overlay .meta{color:#9fb0c7;font-size:13px;margin-top:6px}
  #overlay .close{margin-top:10px;padding:8px 12px;border-radius:8px;border:none;background:#00d4ff;color:#001;font-weight:800;cursor:pointer}
  @media(min-width:900px){
    #overlay{max-width:720px}
  }
</style>
</head>
<body>
  <div id="wrap" aria-hidden="true"></div>

  <div id="ui-top" role="navigation">
    <div class="brand" aria-label="Trox">
      <div class="mark">TRX</div>
      <div style="line-height:1">
        <div style="font-size:12px;color:#9fb0c7">ŸÖÿ¥ÿ±Ÿàÿπ ÿ™ÿ¨ÿ±Ÿäÿ®Ÿä</div>
        <div style="font-weight:800">Trox</div>
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="btnAuth">üîê</button>
      <button class="btn primary" id="btnCreate">üöÄ</button>
    </div>
  </div>

  <div id="hint">ÿßÿ≥ÿ≠ÿ® ŸÑÿ™ÿ≠ÿ±ŸäŸÉ ÿßŸÑŸÖÿ¥ŸáÿØ ‚Ä¢ ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÉÿ®ÿ≥ŸàŸÑÿ©</div>

  <div id="overlay" role="dialog" aria-modal="true">
    <h3 id="ovTitle">...</h3>
    <div class="meta" id="ovMeta"></div>
    <p id="ovBody"></p>
    <button class="close" id="ovClose">ÿ•ÿ∫ŸÑÿßŸÇ</button>
  </div>

  <!-- three.js r128 and OrbitControls (non-module) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>

  <script>
  // mobile-first scene ‚Äî optimized
  const container = document.getElementById('wrap');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle'), ovMeta = document.getElementById('ovMeta'), ovBody = document.getElementById('ovBody');
  const ovClose = document.getElementById('ovClose');
  const btnAuth = document.getElementById('btnAuth'), btnCreate = document.getElementById('btnCreate');

  let renderer, scene, camera, controls, raycaster;
  const capsules = [];
  let particles = [];
  let mouse = new THREE.Vector2();
  let isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints>0;
  const isMobile = window.innerWidth < 760 || isTouch;

  init();
  animate();

  function init(){
    renderer = new THREE.WebGLRenderer({ antialias: !isMobile, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000010, 1);
    container.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(0, 6, isMobile ? 36 : 28);

    // lights
    const hemi = new THREE.HemisphereLight(0x8899ff, 0x080820, 0.6); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(10,20,10); scene.add(dir);

    // stars (fewer on mobile)
    const starCount = isMobile ? 600 : 1200;
    const pos = new Float32Array(starCount*3);
    for(let i=0;i<starCount;i++){
      pos[i*3] = (Math.random()-0.5)*2000;
      pos[i*3+1] = (Math.random()-0.5)*2000;
      pos[i*3+2] = (Math.random()-0.5)*2000;
    }
    const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const m = new THREE.PointsMaterial({ color:0xbfefff, size: isMobile?0.9:0.8, transparent:true, opacity:0.8 });
    const stars = new THREE.Points(g,m); scene.add(stars);

    // controls tuned for mobile
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.09;
    controls.rotateSpeed = isMobile ? 0.35 : 0.6;
    controls.zoomSpeed = isMobile ? 0.9 : 0.8;
    controls.minDistance = 6; controls.maxDistance = 220;
    controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

    raycaster = new THREE.Raycaster();

    // make capsules (fewer on mobile)
    const count = isMobile ? 9 : 20;
    for(let i=0;i<count;i++){
      const cap = makeHexCapsule(i);
      scene.add(cap);
      capsules.push(cap);
    }

    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown, {passive:false});
    renderer.domElement.addEventListener('touchstart', onPointerDown, {passive:false});
    ovClose.addEventListener('click', ()=> overlay.style.display='none');
    btnAuth.addEventListener('click', ()=> location.href='auth.html');
    btnCreate.addEventListener('click', ()=> location.href='create.html');
  }

  function makeHexCapsule(i){
    // colors by index (demo ranks)
    const rank = (i%7===0)? 'legend' : (i%3===0)? 'special' : 'common';
    const col = rank==='legend' ? 0xffd166 : (rank==='special' ? 0xb36aff : 0x44b3ff);

    const geom = new THREE.CylinderGeometry(1.2,1.2,1.8,6,1,false);
    geom.rotateX(Math.PI/2);
    const mat = new THREE.MeshStandardMaterial({ color:col, metalness:0.85, roughness:0.24, emissive:0x000000 });
    const mesh = new THREE.Mesh(geom, mat);

    // plate decoration
    const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=256;
    const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,256,256); ctx.strokeStyle='rgba(255,255,255,0.06)';
    for(let k=0;k<5;k++){ ctx.strokeRect(18+k*8,18+k*8,220-k*16,220-k*16); }
    ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.font='bold 36px sans-serif'; ctx.textAlign='center'; ctx.fillText('‚óä',128,150);
    const tex = new THREE.CanvasTexture(canvas);
    const plate = new THREE.Mesh(new THREE.CircleGeometry(0.5,32), new THREE.MeshStandardMaterial({ map:tex, metalness:0.6, roughness:0.25, side:THREE.DoubleSide }));
    plate.position.set(0,0,0.95); plate.rotateX(Math.PI/2);
    const glow = new THREE.Mesh(new THREE.PlaneGeometry(2.6,2.6), new THREE.MeshBasicMaterial({ color:col, transparent:true, opacity:0.06, blending:THREE.AdditiveBlending }));
    glow.position.set(0,0,-0.2);

    const group = new THREE.Group(); group.add(mesh); group.add(plate); group.add(glow);
    group.position.set((Math.random()-0.5)*60, (Math.random()-0.5)*30, (Math.random()-0.5)*60);
    group.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
    group.scale.setScalar(THREE.MathUtils.lerp(1.05, 1.5, Math.random()));
    group.userData = { title:`ŸÉÿ®ÿ≥ŸàŸÑÿ© #${i+1}`, message:`Ÿáÿ∞Ÿá ÿ±ÿ≥ÿßŸÑÿ© ÿ™ÿ¨ÿ±Ÿäÿ®Ÿäÿ© ŸÑŸÑŸÉÿ®ÿ≥ŸàŸÑÿ© ÿ±ŸÇŸÖ ${i+1}.\nŸÖÿ±ÿ≠ÿ®ÿß ÿ®ŸÉ ŸÅŸä Trox!`, username:`User${i+1}`, rank, isOpen:false };
    return group;
  }

  function onPointerDown(ev){
    ev.preventDefault();
    const rect = renderer.domElement.getBoundingClientRect();
    const clientX = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX);
    const clientY = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY);
    if(clientX===undefined) return;
    mouse.x = ((clientX - rect.left)/rect.width)*2 - 1;
    mouse.y = -((clientY - rect.top)/rect.height)*2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const objs = [];
    capsules.forEach(c=> objs.push(c));
    const hits = raycaster.intersectObjects(scene.children, true);
    if(hits.length>0){
      // find group
      let o = hits[0].object;
      while(o && !capsules.includes(o)) o = o.parent;
      // sometimes hit child; find top-level in our capsules array:
      let top = null;
      for(const g of capsules){ if(g===o || g.children.includes(o) || g.uuid===o.uuid) { top=g; break; } }
      if(!top){ // fallback, find nearest parent
        top = capsules.find(g=> g.uuid=== (o&&o.parent?o.parent.uuid: null));
      }
      if(top) openCapsule(top);
    }
  }

  function openCapsule(g){
    if(g.userData.isOpen) return;
    g.userData.isOpen = true;
    // split visual: clone left & right, remove original
    const left = g.clone(true), right = g.clone(true);
    left.position.copy(g.position); right.position.copy(g.position);
    left.quaternion.copy(g.quaternion); right.quaternion.copy(g.quaternion);
    left.scale.copy(g.scale); right.scale.copy(g.scale);
    scene.add(left); scene.add(right);
    scene.remove(g);

    // particles
    particleFlash(left.position, 26, g.userData.rank);
    // sound (soft) - simple oscillator (mobile browsers may require user gesture which we have)
    try{ const ctx = new (window.AudioContext||window.webkitAudioContext)(); const o = ctx.createOscillator(), ga = ctx.createGain(); o.type='sine'; o.frequency.value=420; o.connect(ga); ga.connect(ctx.destination); ga.gain.value=0.0001; ga.gain.exponentialRampToValueAtTime(0.08, ctx.currentTime+0.02); o.start(); ga.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.6); setTimeout(()=>{ o.stop(); ctx.close(); },650); }catch(e){}

    // animate separation
    const start = performance.now(); const dur=420;
    function step(t){
      const p = Math.min(1,(t-start)/dur); const e = 1 - Math.pow(1-p,3);
      const sep = new THREE.Vector3(1,0,0).applyQuaternion(left.quaternion).multiplyScalar(2.0 * e * (1 + (left.scale.x-1)*0.4));
      left.position.copy(g.position).add(sep.clone().multiplyScalar(-1));
      right.position.copy(g.position).add(sep);
      left.rotation.x += 0.02*(1+e); right.rotation.x -= 0.02*(1+e);
      if(p<1) requestAnimationFrame(step);
      else {
        // show overlay
        ovTitle.textContent = g.userData.title || 'ŸÉÿ®ÿ≥ŸàŸÑÿ© ÿÆÿßŸÑÿØÿ©';
        ovMeta.textContent = `${g.userData.username || 'ŸÖÿ¨ŸáŸàŸÑ'} ‚Ä¢ ${g.userData.rank || 'ÿπÿßÿØŸäÿ©'}`;
        ovBody.textContent = g.userData.message || 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ±ÿ≥ÿßŸÑÿ©';
        overlay.style.display = 'block';
        // auto reassemble after 5s
        setTimeout(()=> {
          const s2 = performance.now(), d2=380;
          function reasm(t2){
            const q = Math.min(1,(t2-s2)/d2); const e2 = 1 - Math.pow(1-q,3);
            const sepNow = sep.clone().multiplyScalar(1-e2);
            left.position.copy(g.position).add(sepNow.clone().multiplyScalar(-1));
            right.position.copy(g.position).add(sepNow);
            left.rotation.x += 0.002; right.rotation.x -= 0.002;
            if(q<1) requestAnimationFrame(reasm);
            else {
              scene.remove(left); scene.remove(right);
              scene.add(g);
              g.userData.isOpen = false;
              overlay.style.display = 'none';
            }
          }
          requestAnimationFrame(reasm);
        }, 5000);
      }
    }
    requestAnimationFrame(step);
  }

  function particleFlash(center, amount=20, rank){
    for(let i=0;i<amount;i++){
      const geom = new THREE.SphereGeometry(0.04 + Math.random()*0.12, 6,6);
      const color = (rank && rank.toString().toLowerCase().includes('legend')) ? 0xffd166 : (rank && rank.toString().toLowerCase().includes('special') ? 0xb36aff : 0x44b3ff);
      const mat = new THREE.MeshBasicMaterial({ color, transparent:true, opacity:1, blending: THREE.AdditiveBlending });
      const p = new THREE.Mesh(geom, mat);
      p.position.copy(center);
      p.userData = { vel: new THREE.Vector3((Math.random()-0.5)*2.2, (Math.random()-0.5)*2.2, (Math.random()-0.5)*2.2), life:0 };
      scene.add(p); particles.push(p);
    }
  }

  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.position.addScaledVector(p.userData.vel, dt);
      p.userData.life += dt;
      p.material.opacity = Math.max(0, 1 - p.userData.life*1.2);
      if(p.userData.life > 1.2){ scene.remove(p); particles.splice(i,1); }
    }
  }

  function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    const dt = Math.min((now - (animate._prev || now))/1000, 0.06);
    animate._prev = now;

    // float capsules
    capsules.forEach(c=>{
      c.userData._t = (c.userData._t || Math.random()*100) + dt*0.5;
      c.position.y += Math.sin(c.userData._t)*0.01;
      c.rotation.y += 0.0012;
    });

    updateParticles(dt);
    controls.update();
    renderer.render(scene, camera);
  }

  function onResize(){
    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  window.addEventListener('resize', onResize);

  </script>
</body>
</html>
